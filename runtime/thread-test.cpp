#include "gtest/gtest.h"

#include "frame.h"
#include "marshal.h"
#include "runtime.h"
#include "thread.h"

namespace python {

TEST(ThreadTest, RunEmptyFunction) {
  Runtime runtime;
  HandleScope scope;
  const char* buffer =
      "\x33\x0D\x0D\x0A\x3B\x5B\xB8\x59\x05\x00\x00\x00\xE3\x00\x00\x00\x00\x00"
      "\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x40\x00\x00\x00\x73\x04\x00"
      "\x00\x00\x64\x00\x53\x00\x29\x01\x4E\xA9\x00\x72\x01\x00\x00\x00\x72\x01"
      "\x00\x00\x00\x72\x01\x00\x00\x00\xFA\x07\x70\x61\x73\x73\x2E\x70\x79\xDA"
      "\x08\x3C\x6D\x6F\x64\x75\x6C\x65\x3E\x01\x00\x00\x00\x73\x00\x00\x00\x00";
  Marshal::Reader reader(&scope, &runtime, buffer);

  int32 magic = reader.readLong();
  EXPECT_EQ(magic, 0x0A0D0D33);
  int32 mtime = reader.readLong();
  EXPECT_EQ(mtime, 0x59B85B3B);
  int32 size = reader.readLong();
  EXPECT_EQ(size, 5);

  auto code = reader.readObject();
  ASSERT_TRUE(code->isCode());
  EXPECT_EQ(Code::cast(code)->argcount(), 0);

  Thread thread(1 * KiB);
  Object* result = thread.run(code);
  ASSERT_EQ(result, None::object()); // returns None
}

TEST(ThreadTest, RunHelloWorld) {
  Runtime runtime;
  HandleScope scope;
  const char* buffer =
      "\x33\x0D\x0D\x0A\x1B\x69\xC1\x59\x16\x00\x00\x00\xE3\x00\x00\x00\x00\x00"
      "\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x40\x00\x00\x00\x73\x0C\x00"
      "\x00\x00\x65\x00\x64\x00\x83\x01\x01\x00\x64\x01\x53\x00\x29\x02\x7A\x0C"
      "\x68\x65\x6C\x6C\x6F\x2C\x20\x77\x6F\x72\x6C\x64\x4E\x29\x01\xDA\x05\x70"
      "\x72\x69\x6E\x74\xA9\x00\x72\x02\x00\x00\x00\x72\x02\x00\x00\x00\xFA\x0D"
      "\x68\x65\x6C\x6C\x6F\x77\x6F\x72\x6C\x64\x2E\x70\x79\xDA\x08\x3C\x6D\x6F"
      "\x64\x75\x6C\x65\x3E\x01\x00\x00\x00\x73\x00\x00\x00\x00";
  Marshal::Reader reader(&scope, &runtime, buffer);

  int32 magic = reader.readLong();
  EXPECT_EQ(magic, 0x0A0D0D33);
  int32 mtime = reader.readLong();
  EXPECT_EQ(mtime, 0x59C1691B);
  int32 size = reader.readLong();
  EXPECT_EQ(size, 22);

  auto code = reader.readObject();
  ASSERT_TRUE(code->isCode());
  EXPECT_EQ(Code::cast(code)->argcount(), 0);

  Thread thread(1 * KiB);
  Object* result = thread.run(code);
  ASSERT_EQ(result, None::object()); // returns None
}

TEST(ThreadTest, PushPopObject) {
  Thread thread(1 * KiB);
  auto pushed = SmallInteger::fromWord(12345);
  thread.pushObject(pushed);
  auto popped = thread.popObject();
  ASSERT_TRUE(popped->isSmallInteger());
  ASSERT_EQ(pushed->value(), SmallInteger::cast(popped)->value());
}

TEST(ThreadTest, PushPopFrame) {
  Runtime runtime;
  Thread thread(1 * KiB);

  auto sentinel = SmallInteger::fromWord(1111);
  thread.pushObject(sentinel);

  // Push and pop a frame
  auto code = runtime.newCode();
  auto frame = thread.pushFrame(code);
  thread.popFrame(frame);

  // Make sure we can pop the correct sentinel value
  auto popped = thread.popObject();
  ASSERT_TRUE(popped->isSmallInteger());
  EXPECT_EQ(SmallInteger::cast(popped)->value(), sentinel->value());
}

TEST(ThreadTest, ReadFrameLocals) {
  Runtime runtime;
  Thread thread(1 * KiB);

  // Push args on the stack in the sequence generated by CPython
  auto arg1 = SmallInteger::fromWord(1111);
  thread.pushObject(arg1);
  auto arg2 = SmallInteger::fromWord(2222);
  thread.pushObject(arg2);
  auto arg3 = SmallInteger::fromWord(3333);
  thread.pushObject(arg3);

  // Push a frame for a code object that expects 3 arguments and needs space
  // for 3 local variables
  auto code = runtime.newCode();
  Code::cast(code)->setArgcount(3);
  Code::cast(code)->setNlocals(6);
  auto frame = thread.pushFrame(code);

  // Make sure we can read the args from the frame
  Object** locals = frame->locals();

  ASSERT_TRUE(locals[0]->isSmallInteger());
  EXPECT_EQ(SmallInteger::cast(locals[3])->value(), arg3->value());

  ASSERT_TRUE(locals[1]->isSmallInteger());
  EXPECT_EQ(SmallInteger::cast(locals[4])->value(), arg2->value());

  ASSERT_TRUE(locals[2]->isSmallInteger());
  EXPECT_EQ(SmallInteger::cast(locals[5])->value(), arg1->value());
}

TEST(ThreadTest, EncodeTryBlock) {
  TryBlock block(100, 200, 300);
  TryBlock decoded = TryBlock::fromSmallInteger(block.asSmallInteger());
  EXPECT_EQ(decoded.kind, block.kind);
  EXPECT_EQ(decoded.handler, block.handler);
  EXPECT_EQ(decoded.level, block.level);
}

} // namespace python
